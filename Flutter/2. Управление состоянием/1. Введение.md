---
title: 1. Введение
description: description
author: Геннадий Альхеев
tableOfContents: false
---
# 1. Введение #

После того, как вы начнете изучать Flutter, наступит момент, когда возникнет необходимость делиться состоянием приложения между экранами или по всему приложению. Существует множество подходов, которые можно использовать, и множество вопросов, которые нужно учитывать.

![](https://docs.flutter.dev/assets/images/docs/development/data-and-backend/state-mgmt/state-management-explainer.gif)

## История одного приложения ##

Представьте, что вы решили создать приложение для заметок и назавали его **NoteKeeper**. Идея проста: пользователи могут создавать, редактировать и удалять заметки. Вы быстро реализуете базовый функционал, используя `setState()` для обновления интерфейса. Всё работает отлично, и вы чувствуете себя на вершине мира разработки. Но вот пользователи начинают просить больше: возможность помечать заметки как важные, фильтровать их по категориям, синхронизировать с облаком. Вы с энтузиазмом берётесь за новые задачи, но постепенно замечаете, что код становится всё более запутанным. Управление состоянием превращается в головоломку, а каждое новое изменение приводит к неожиданным багам.

## Эволюция проблемы управления состоянием ##

С ростом функциональности появляются новые требования, и чтобы удовлетворить эти запросы, вы начинаете добавлять `setState()` в различные части кода. Однако, с каждым новым вызовом `setState()`, он становится всё более запутанным, из чего вытекает целый список проблем:

| Проблема | Описание проблемы |
|-------------|-------------|
| Разрозненность логики | Механизмы изменения состояния распределены по множеству компонентов и файлов, что затрудняет понимание того, как различные части приложения взаимодействуют друг с другом. |
| Сложность синхронизации | Обновления, сделанные в одном компоненте, могут не корректно отражаться в других, что приводит к неконсистентности данных между экранами или частями интерфейса. Иными словами, изменения, сделанные на одном экране, не всегда корректно отражаются на другом. |
| Проблемы с производительностью | Частые и ненужные перерисовки пользовательского интерфейса увеличивают нагрузку на приложение, снижая его общую отзывчивость и плавность работы. |
| Непредсказуемое поведение | Из-за несогласованности логики обновления состояния интерфейс может вести себя нестабильно. В некоторых случаях изменения применяются с задержкой, а в других — интерфейс может полностью перестать реагировать, создавая эффект "зависания". |
| Рост числа багов | Разделение логики состояния между различными участками кода усложняет её тестирование и отладку. Это приводит к появлению трудно воспроизводимых ошибок, особенно в сценариях, где одновременные изменения состояния конфликтуют друг с другом. |
| Сложность поддержки | Добавление новых функций требует больше времени на понимание и модификацию существующего кода. |

Вы начинаете ощущать, что текущий подход не справляется с растущими требованиями, но не до конца понимаете, как именно решить эти проблемы.

## Архитектурные паттерны и стейт-менеджеры: понимание отношений ##

На этом этапе вы натыкаетесь на термины **архитектурные паттерны** и **стейт-менеджеры**, но не до конца понимаете, чем они отличаются, каковы их зоны ответственности и как они взаимодействуют друг с другом.

### Чем отличаются архитектурные паттерны и стейт-менеджеры?

- **Архитектурные паттерны** — это высокоуровневые концепции, определяющие общую структуру приложения и распределение ответственности между его компонентами. Они помогают организовать код так, чтобы он был более понятным, поддерживаемым и масштабируемым. К ним можно отнести: MVC (Model-View-Controller), MVVM (Model-View-ViewModel), Чистая архитектура.

- **Стейт-менеджеры** — это инструменты или библиотеки, которые помогают эффективно управлять состоянием приложения. Они предоставляют механизмы для хранения, изменения и распространения состояния между различными компонентами. Например: Provider, BLoC, Redux, MobX.

Проще говоря, архитектурные паттерны определяют **структуру и организацию кода**, а стейт-менеджеры предоставляют **конкретные инструменты для управления состоянием** внутри этой структуры.

|                   | **Архитектурные паттерны**                                  | **Стейт-менеджеры**                                        |
|-------------------|------------------------------------------------------------|----------------------------------------------------------|
| **Первичная роль**| Организация структурного взаимодействия компонентов и распределение функций. | Обеспечение инструментов для изменения и хранения состояния. |
| **Итоговая роль** | Разработка стратегий обработки данных и управления состоянием.           | Согласование данных состояния с пользовательским интерфейсом. |


### Как они работают вместе?

Архитектурный паттерн задаёт общую структуру приложения, а стейт-менеджер обеспечивает конкретные механизмы для управления состоянием внутри этой структуры. Вместе они помогают создать масштабируемое и поддерживаемое приложение.

## Чистая архитектура: глобальная концепция

### Что такое чистая архитектура?

**Чистая архитектура** (Clean Architecture), предложенная Робертом Мартином, представляет собой набор принципов, направленных на создание гибких, легко тестируемых и масштабируемых систем. Главные принципы:

- **Независимость от фреймворков:** Архитектура приложения не должна зависеть от внешних библиотек или фреймворков.
- **Тестируемость:** Бизнес-логика должна быть легко тестируемой без необходимости запуска UI или взаимодействия с базой данных.
- **Независимость от UI:** Можно менять пользовательский интерфейс без изменения остальной системы.
- **Независимость от базы данных:** Бизнес-правила не должны зависеть от способов хранения данных.

### Как чистая архитектура связана с архитектурными паттернами и стейт-менеджерами?

- **Архитектурные паттерны** (такие как MVC или MVVM) могут быть использованы внутри слоёв чистой архитектуры для организации кода.
- **Стейт-менеджеры** помогают реализовать передачу данных и управление состоянием между этими слоями, обеспечивая взаимодействие между бизнес-логикой и UI.

**Например:**

- **Внутренние слои** содержат бизнес-логику и сущности, которые не зависят от внешних компонентов.
- **Промежуточные слои** включают интерфейсы и адаптеры, которые позволяют общаться между внутренними и внешними слоями.
- **Внешние слои** включают UI и фреймворки.

## Как архитектурные паттерны и стейт-менеджеры работают вместе: концептуальный пример

Представьте, что вы строите многоэтажное здание:

- **Архитектурный паттерн** — это общий план здания: сколько этажей, как они будут расположены, какие будут комнаты и как они будут связаны.
- **Стейт-менеджер** — это инженерные системы внутри здания: электричество, водоснабжение, вентиляция. Они обеспечивают функционирование здания в соответствии с архитектурным планом.

Без хорошо продуманной архитектуры здание может быть небезопасным или неудобным. Без инженерных систем оно не будет функционировать должным образом.

## Возвращаясь к нашему приложению NoteKeeper

В вашем приложении **NoteKeeper** вы решаете использовать **MVVM** в сочетании с **Provider**. Вот как это выглядит:

- **Model**: класс `Note`, представляющий заметку.
- **ViewModel**: класс `NotesViewModel`, управляющий списком заметок и их состоянием.
- **View**: виджеты Flutter, отвечающие за отображение и взаимодействие с пользователем.

Используя **Provider**, вы предоставляете `NotesViewModel` всему приложению. Теперь, когда вы вызываете метод `toggleImportant`, изменения автоматически отражаются на всех экранах, без необходимости вручную вызывать `setState()` в каждом виджете.

### Преимущества такого подхода:

- **Централизация состояния:** Все данные хранятся в одном месте, упрощая доступ и модификацию.
- **Отделение бизнес-логики от UI:** Код становится более чистым и легче поддерживается.
- **Улучшенная производительность:** Обновляются только те части интерфейса, которые действительно изменились.
- **Масштабируемость:** Добавление новых функций становится проще, так как архитектура приложения хорошо структурирована.
- **Упрощённое тестирование:** Отделение логики и UI позволяет писать модульные тесты для бизнес-логики независимо от интерфейса.

## Глубже в историю: эволюция управления состоянием

### От простого к сложному

В начале 2000-х годов разработка GUI-приложений была относительно простой задачей. Однако, по мере роста сложности приложений, разработчики столкнулись с необходимостью более структурированных подходов к организации кода. Это привело к появлению архитектурных паттернов, таких как MVC, которые помогли разделить ответственность между различными компонентами приложения.

### Влияние функционального программирования

Идеи функционального программирования, такие как неизменяемость данных и чистые функции, оказали влияние на подходы к управлению состоянием. В частности, это привело к появлению таких стейт-менеджеров, как Redux, где состояние считается неизменяемым, и изменения происходят путем создания новых копий состояния.

### Реактивное программирование

Появление реактивного программирования и использование потоков данных (Streams) внесли свой вклад в развитие стейт-менеджеров. Паттерн BLoC во Flutter основан на этой концепции, позволяя эффективно управлять асинхронными данными и событиями.

## Почему стейт-менеджеры необходимы помимо архитектурных паттернов?

Архитектурные паттерны задают **общую структуру** приложения и определяют, как компоненты взаимодействуют друг с другом. Однако они не решают конкретных задач управления состоянием, таких как:

- **Централизованное хранение данных:** Как хранить и организовывать данные таким образом, чтобы они были доступны во всех нужных частях приложения.
- **Реактивные обновления UI:** Как обеспечить автоматическое обновление интерфейса при изменении данных без необходимости ручных вызовов `setState()`.
- **Управление сложными состояниями:** Как эффективно управлять состояниями, которые зависят от асинхронных операций или требуют сложной логики обработки.

Стейт-менеджеры предоставляют готовые решения для этих задач, интегрируясь в архитектурные паттерны и обеспечивая эффективное управление состоянием внутри заданной структуры.

### Пример из реальной жизни: строительный проект

Представьте, что вы строите многоэтажное здание. **Архитектурный паттерн** — это общий план здания: сколько этажей, как они будут расположены, какие будут комнаты и как они будут связаны. **Стейт-менеджер** — это инженерные системы внутри здания: электричество, водоснабжение, вентиляция. Они обеспечивают функционирование здания в соответствии с архитектурным планом.

Без хорошо продуманной архитектуры здание может быть небезопасным или неудобным. Без инженерных систем оно не будет функционировать должным образом.

## Возможные вопросы

1. **Почему недостаточно просто использовать `setState()`?**
   
   `setState()` хорошо работает для локальных изменений в небольших виджетах. Однако, по мере роста приложения, возникают проблемы с поддерживаемостью, синхронизацией данных между экранами и производительностью. Стейт-менеджеры и архитектурные паттерны помогают решить эти проблемы, обеспечивая более структурированный и централизованный подход к управлению состоянием.

2. **Чем отличаются архитектурные паттерны от стейт-менеджеров?**
   
   Архитектурные паттерны определяют **структуру и распределение ответственности** в приложении, помогая организовать код. Стейт-менеджеры предоставляют **инструменты и механизмы** для управления состоянием внутри этой структуры. Вместе они создают мощный фундамент для разработки масштабируемых и поддерживаемых приложений.

3. **Можно ли использовать несколько стейт-менеджеров в одном приложении?**
   
   Да, иногда это оправдано. Например, можно использовать **Provider** для управления глобальным состоянием и `setState()` для локальных изменений в отдельных виджетах. Однако важно избегать избыточности и усложнения кода, поэтому выбор следует делать осознанно, основываясь на потребностях проекта.

4. **Как выбрать подходящий стейт-менеджер?**
   
   Выбор стейт-менеджера зависит от сложности приложения, требований к производительности, предпочтений команды и личных предпочтений. Для небольших проектов подойдет **Provider**, тогда как для более сложных приложений с большим количеством бизнес-логики и асинхронных операций лучше рассмотреть **BLoC** или **Redux**. Важно также учитывать удобство интеграции и существующую экосистему инструментов.

5. **Как стейт-менеджеры влияют на тестируемость приложения?**
   
   Стейт-менеджеры способствуют улучшению тестируемости, позволяя отделить бизнес-логику от UI. Это делает возможным написание модульных тестов для бизнес-логики без необходимости взаимодействовать с пользовательским интерфейсом. Чистое разделение ответственности также упрощает изоляцию и тестирование отдельных компонентов системы, повышая качество и надёжность кода.

6. **Что делать, если выбранный стейт-менеджер перестаёт соответствовать требованиям проекта?**
   
   Если выбранный стейт-менеджер не справляется с новыми требованиями проекта, важно быть готовым к его замене. Чистая архитектура и правильное разделение ответственности облегчают процесс миграции на другой стейт-менеджер. Важно заранее планировать структуру приложения таким образом, чтобы минимизировать затраты на смену инструментов в будущем, сохраняя гибкость и модульность кода.

## Заключение

Управление состоянием — это искусство, требующее понимания как архитектурных концепций, так и практических инструментов. Правильное сочетание архитектурного паттерна и стейт-менеджера позволяет создавать приложения, которые радуют пользователей и упрощают жизнь разработчикам.

В этой главе мы прошли путь от простого приложения до понимания необходимости структурированного подхода к управлению состоянием. В следующих главах мы глубже погрузимся в различные стейт-менеджеры и архитектурные паттерны, изучим их особенности и научимся применять их на практике.
